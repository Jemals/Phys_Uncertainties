#! /usr/bin/env python

import math

# Simplicity is the best course of action, also: I'm too tired to mess around with classes right now

#NB: fixed for-ranges to reflect new knowledge of "up to and not including" principle

# General %uncertainty functions
def percented_list(value_list, uncertainty_list):
    out_list = []
    for i in range(0, len(value_list) ):
        out_list.append(round( (float(uncertainty_list[i]) / float(value_list[i])*100.0), 4))
    return out_list


def combo_list(cented_read, cented_rand, cented_calib):
    combo_list = []

    # try to find the shortest list so to avoid errors. Shouldn't matter here
    if len(cented_read) < len(cented_rand) < len(cented_calib):
        shortest = len(cented_read)
    elif len(cented_rand) < len(cented_read) < len(cented_calib):
        shortest = len(cented_rand)
    else:
        shortest = len(cented_calib)

    for i in range(0, 5):
        combo_list.append(round(math.sqrt(cented_read[i]**2 + cented_rand[i]**2 + cented_calib[i]**2)), 4)

    return combo_list

def powerFix(combo_list, term_power):   	# If functions are first-order and variables are passed by reference,
    for i in range(0, len(combo_list)):     # no new value need be assigned so the function can be called
        combo_list[i] *= term_power         # merely to update the combined list.

''' combo_list is updated and so just using powerFix(combined_unc, 3) changes the original list to suit the
power uncertainty '''

# Specific %uncertainty functions
def get_reading_unc(value_list, scale_unc):
    read_unc_list = []
    for i in range(0, len(value_list)):
        read_unc_list.append(round((scale_unc / value_list[i]), 4))
    return read_unc_list

#def getLeastSF(dec_value): # Potentially unsafe as I don't check if it's actually a decimal value
'''GET TO THIS!!!'''


def get_calibration_unc(value_list):
    calib_list = []
    for i in range(0, len(value_list)):
        if value_list[i] == 0:
            print("Empty entry @ {0}, resorting to 0 val".format(value_list[i]))
            calib_list.append(0.0)

        calib_list.append(round(round(value_list[i]*0.005, 4) + float("0."+ ( len(str(round(value_list[i]*0.005, 4)))-3) *"0" +"1"),4)


        '''
        elif len(str(0.005*value_list[i])) == 3:
            calib_list.append(0.005*value_list[i] + 0.1)
        elif len(str(0.005*value_list[i])) == 4:
            calib_list.append(0.005*value_list[i] + 0.01)
        elif len(str(0.005*value_list[i])) == 5:
            calib_list.append(0.005*value_list[i] + 0.001)
        elif len(str(0.005*value_list[i])) == 6:
            calib_list.append(0.005*value_list[i] + 0.0001)
        elif len(str(0.005*value_list[i])) == 7:
            calib_list.append(0.005*value_list[i] + 0.00001)
        elif len(str(0.005*value_list[i])) == 8:
            calib_list.append(0.005*value_list[i] + 0.000001)
        elif len(str(0.005*value_list[i])) == 9:
            calib_list.append(0.005*value_list[i] + 0.0000001)
        elif len(str(0.005*value_list[i])) == 10:
            calib_list.append(0.005*value_list[i] + 0.00000001)
        else:
            print("Error! Entry {0}:{1} within unknown range!".format(i, value_list[i]))
            calib_list.append(0.0)
        '''
    return calib_list

def get_random_unc(repeated_results):
    #number_values = len(repeated_results[0])
    ##sorted_list = qSort(repeated_results)
    sorted_list = []
    for i in range(0, len(repeated_results)):
        sorted_list.append(sorted(repeated_results[i]))


    random_uns = []
    for i in range(0, len(sorted_list)):
        random_uns.append(round((sorted_list[i][-1] - sorted_list[i][0]) / len(sorted_list[i]), 4))

    return random_uns

# General


'''
def qSort(repeated_list):
    if repeated_list == []:
        return []
    else:
        for i in range(0, len(repeated_list[0])):
            pivot = repeated_list[i][0]
            lesser = qSort([x for x in repeated_list[1:] if x < pivot])
            greater = qSort([x for x in repeated_list[1:] if x >= pivot])
            sorted_list.append(lesser + [pivot] + greater)
        return sorted_list
'''
